'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _deck = require('deck.gl');

var _luma = require('luma.gl');

var _polygonTesselator = require('./polygon-tesselator');

var _solidPolygonLayerVertex = require('./solid-polygon-layer-vertex.glsl');

var _solidPolygonLayerVertex2 = _interopRequireDefault(_solidPolygonLayerVertex);

var _solidPolygonLayerVertex3 = require('./solid-polygon-layer-vertex-64.glsl');

var _solidPolygonLayerVertex4 = _interopRequireDefault(_solidPolygonLayerVertex3);

var _solidPolygonLayerFragment = require('./solid-polygon-layer-fragment.glsl');

var _solidPolygonLayerFragment2 = _interopRequireDefault(_solidPolygonLayerFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var enable64bitSupport = _deck.experimental.enable64bitSupport,
    get = _deck.experimental.get;

// Polygon geometry generation is managed by the polygon tesselator

var defaultLineColor = [0x0, 0x0, 0x0, 0xff];
var defaultFillColor = [0x0, 0x0, 0x0, 0xff];

var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // elevation multiplier
  elevationScale: 1,

  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return get(f, 'polygon') || get(f, 'geometry.coordinates');
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return get(f, 'elevation') || get(f, 'properties.height') || 0;
  },
  // Accessor for colors
  getFillColor: function getFillColor(f) {
    return get(f, 'fillColor') || get(f, 'properties.color') || defaultFillColor;
  },
  getLineColor: function getLineColor(f) {
    return get(f, 'lineColor') || get(f, 'properties.color') || defaultLineColor;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.0, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

// Side model attributes
var SIDE_FILL_POSITIONS = new Float32Array([
// top left corner
0, 1,
// bottom left corner
0, 0,
// top right corner
1, 1,
// bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([
// top right corner
1, 1,
// top left corner
0, 1,
// bottom left corner
0, 0,
// bottom right corner
1, 0]);

// Model types
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: { instanced: 0 },
    positions: { instanced: 0 },
    positions64xyLow: { instanced: 0 },
    elevations: { instanced: 0 },
    fillColors: { name: 'colors', instanced: 0 },
    pickingColors: { instanced: 0 }
  },
  SIDE: {
    positions: { instanced: 1 },
    positions64xyLow: { instanced: 1 },
    nextPositions: { instanced: 1 },
    nextPositions64xyLow: { instanced: 1 },
    elevations: { instanced: 1 },
    fillColors: { name: 'colors', instanced: 1 },
    pickingColors: { instanced: 1 }
  },
  WIRE: {
    positions: { instanced: 1 },
    positions64xyLow: { instanced: 1 },
    nextPositions: { instanced: 1 },
    nextPositions64xyLow: { instanced: 1 },
    elevations: { instanced: 1 },
    lineColors: { name: 'colors', instanced: 1 },
    pickingColors: { instanced: 1 }
  }
};

var SolidPolygonLayer = function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return enable64bitSupport(this.props) ? { vs: _solidPolygonLayerVertex4.default, fs: _solidPolygonLayerFragment2.default, modules: ['project64', 'lighting', 'picking'] } : { vs: _solidPolygonLayerVertex2.default, fs: _solidPolygonLayerFragment2.default, modules: ['lighting', 'picking'] }; // 'project' module added by default.
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({
        numInstances: 0,
        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array
      });

      var attributeManager = this.state.attributeManager;

      var noAlloc = true;
      /* eslint-disable max-len */
      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },
        positions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        nextPositions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          accessor: ['extruded', 'getElevation'],
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: _luma.GL.UNSIGNED_BYTE,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          noAlloc: noAlloc
        },
        pickingColors: { size: 3, type: _luma.GL.UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;


        if (props.fp64 && props.coordinateSystem === _deck.COORDINATE_SYSTEM.LNGLAT) {
          /* eslint-disable max-len */
          attributeManager.add({
            positions64xyLow: { size: 2, accessor: 'fp64', update: this.calculatePositionsLow },
            nextPositions64xyLow: { size: 2, accessor: 'fp64', update: this.calculateNextPositionsLow }
          });
          /* eslint-enable max-len */
        } else {
          attributeManager.remove(['positions64xyLow', 'nextPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          extruded = _props.extruded,
          lightSettings = _props.lightSettings,
          elevationScale = _props.elevationScale;


      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      }, lightSettings);

      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), 'updateState', this).call(this, updateParams);

      this.updateGeometry(updateParams);
      this.updateAttribute(updateParams);

      var props = updateParams.props,
          oldProps = updateParams.oldProps;


      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        this.setState(Object.assign({
          // Set a flag to set attributes to new models
          modelsChanged: true
        }, this._getModels(this.context.gl)));
      }

      if (props.extruded !== oldProps.extruded) {
        this.state.attributeManager.invalidate('extruded');
      }
      if (props.fp64 !== oldProps.fp64) {
        this.state.attributeManager.invalidate('fp64');
      }
    }
  }, {
    key: 'updateGeometry',
    value: function updateGeometry(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;

      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      // When the geometry config  or the data is changed,
      // tessellator needs to be invoked
      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        this.setState({
          polygonTesselator: new _polygonTesselator.PolygonTesselator({ polygons: polygons, IndexType: this.state.IndexType })
        });

        this.state.attributeManager.invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: props.fp64,
          extruded: props.extruded
        });
      }
    }
  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          modelsChanged = _state.modelsChanged;

      // Figure out data length

      attributeManager.update({
        data: props.data,
        numInstances: 0,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (modelsChanged) {
        this._updateAttributes(attributeManager.attributes);
        // clear the flag
        this.setState({ modelsChanged: false });
      } else {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        this._updateAttributes(changedAttributes);
      }
    }
  }, {
    key: '_updateAttributes',
    value: function _updateAttributes(attributes) {
      var modelsByName = this.state.modelsByName;


      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var newAttributes = {};
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var attributeOverride = attributeMap[attributeName];

          if (attributeOverride) {
            var newAttribute = Object.assign({}, attribute, attributeOverride);
            newAttributes[attributeOverride.name || attributeName] = newAttribute;
          }
        }
        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: '_getModels',
    value: function _getModels(gl) {
      var _props2 = this.props,
          id = _props2.id,
          filled = _props2.filled,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;


      var models = {};

      if (filled) {
        models.TOP = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-top',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLES,
            attributes: {
              vertexPositions: { size: 2, isGeneric: true, value: new Float32Array([0, 1]) },
              nextPositions: { size: 3, isGeneric: true, value: new Float32Array(3) },
              nextPositions64xyLow: { size: 2, isGeneric: true, value: new Float32Array(2) }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (filled && extruded) {
        models.SIDE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-side',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_FILL_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isinstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }
      if (extruded && wireframe) {
        models.WIRE = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-wire',
          geometry: new _luma.Geometry({
            drawMode: _luma.GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_WIRE_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isinstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      attribute.target = _luma.GL.ELEMENT_ARRAY_BUFFER;
      var numVertex = attribute.value.length / attribute.size;
      this.setState({ numVertex: numVertex });
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions();
      var numInstances = attribute.value.length / attribute.size;
      this.setState({ numInstances: numInstances });
    }
  }, {
    key: 'calculatePositionsLow',
    value: function calculatePositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: 'calculateNextPositions',
    value: function calculateNextPositions(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions();
    }
  }, {
    key: 'calculateNextPositionsLow',
    value: function calculateNextPositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: 'calculateElevations',
    value: function calculateElevations(attribute) {
      var _this2 = this;

      if (this.props.extruded) {
        attribute.isGeneric = false;
        attribute.value = this.state.polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _this2.props.getElevation(_this2.props.data[polygonIndex]);
          }
        });
      } else {
        attribute.isGeneric = true;
        attribute.value = new Float32Array(1);
      }
    }
  }, {
    key: 'calculateFillColors',
    value: function calculateFillColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getFillColor(_this3.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: 'calculateLineColors',
    value: function calculateLineColors(attribute) {
      var _this4 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this4.props.getLineColor(_this4.props.data[polygonIndex]);
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(_deck.Layer);

exports.default = SolidPolygonLayer;


SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwtbGF5ZXJzL3NyYy9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiZW5hYmxlNjRiaXRTdXBwb3J0IiwiZ2V0IiwiZGVmYXVsdExpbmVDb2xvciIsImRlZmF1bHRGaWxsQ29sb3IiLCJkZWZhdWx0UHJvcHMiLCJmaWxsZWQiLCJleHRydWRlZCIsIndpcmVmcmFtZSIsImZwNjQiLCJlbGV2YXRpb25TY2FsZSIsImdldFBvbHlnb24iLCJmIiwiZ2V0RWxldmF0aW9uIiwiZ2V0RmlsbENvbG9yIiwiZ2V0TGluZUNvbG9yIiwibGlnaHRTZXR0aW5ncyIsImxpZ2h0c1Bvc2l0aW9uIiwiYW1iaWVudFJhdGlvIiwiZGlmZnVzZVJhdGlvIiwic3BlY3VsYXJSYXRpbyIsImxpZ2h0c1N0cmVuZ3RoIiwibnVtYmVyT2ZMaWdodHMiLCJTSURFX0ZJTExfUE9TSVRJT05TIiwiRmxvYXQzMkFycmF5IiwiU0lERV9XSVJFX1BPU0lUSU9OUyIsIkFUVFJJQlVURV9NQVBTIiwiVE9QIiwiaW5kaWNlcyIsImluc3RhbmNlZCIsInBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJlbGV2YXRpb25zIiwiZmlsbENvbG9ycyIsIm5hbWUiLCJwaWNraW5nQ29sb3JzIiwiU0lERSIsIm5leHRQb3NpdGlvbnMiLCJuZXh0UG9zaXRpb25zNjR4eUxvdyIsIldJUkUiLCJsaW5lQ29sb3JzIiwiU29saWRQb2x5Z29uTGF5ZXIiLCJwcm9wcyIsInZzIiwiZnMiLCJtb2R1bGVzIiwiZ2wiLCJjb250ZXh0Iiwic2V0U3RhdGUiLCJudW1JbnN0YW5jZXMiLCJJbmRleFR5cGUiLCJnZXRFeHRlbnNpb24iLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiYXR0cmlidXRlTWFuYWdlciIsInN0YXRlIiwibm9BbGxvYyIsImFkZCIsInNpemUiLCJpc0luZGV4ZWQiLCJ1cGRhdGUiLCJjYWxjdWxhdGVJbmRpY2VzIiwiYWNjZXNzb3IiLCJjYWxjdWxhdGVQb3NpdGlvbnMiLCJjYWxjdWxhdGVOZXh0UG9zaXRpb25zIiwiY2FsY3VsYXRlRWxldmF0aW9ucyIsImFsaWFzIiwidHlwZSIsIlVOU0lHTkVEX0JZVEUiLCJjYWxjdWxhdGVGaWxsQ29sb3JzIiwiY2FsY3VsYXRlTGluZUNvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJvbGRQcm9wcyIsImNvb3JkaW5hdGVTeXN0ZW0iLCJMTkdMQVQiLCJjYWxjdWxhdGVQb3NpdGlvbnNMb3ciLCJjYWxjdWxhdGVOZXh0UG9zaXRpb25zTG93IiwicmVtb3ZlIiwidW5pZm9ybXMiLCJyZW5kZXJVbmlmb3JtcyIsIk9iamVjdCIsImFzc2lnbiIsIm1vZGVscyIsImZvckVhY2giLCJtb2RlbCIsInJlbmRlciIsInVwZGF0ZVBhcmFtcyIsInVwZGF0ZUdlb21ldHJ5IiwidXBkYXRlQXR0cmlidXRlIiwicmVnZW5lcmF0ZU1vZGVscyIsIm1vZGVsc0NoYW5nZWQiLCJfZ2V0TW9kZWxzIiwiaW52YWxpZGF0ZSIsImNoYW5nZUZsYWdzIiwiZ2VvbWV0cnlDb25maWdDaGFuZ2VkIiwiZGF0YUNoYW5nZWQiLCJ1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQiLCJhbGwiLCJwb2x5Z29ucyIsImRhdGEiLCJtYXAiLCJwb2x5Z29uVGVzc2VsYXRvciIsImludmFsaWRhdGVBbGwiLCJ1cGRhdGVQb3NpdGlvbnMiLCJidWZmZXJzIiwiaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMiLCJfdXBkYXRlQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJjaGFuZ2VkQXR0cmlidXRlcyIsImdldENoYW5nZWRBdHRyaWJ1dGVzIiwiY2xlYXJDaGFuZ2VkRmxhZ3MiLCJtb2RlbHNCeU5hbWUiLCJtb2RlbE5hbWUiLCJzZXRWZXJ0ZXhDb3VudCIsIm51bVZlcnRleCIsInNldEluc3RhbmNlQ291bnQiLCJhdHRyaWJ1dGVNYXAiLCJuZXdBdHRyaWJ1dGVzIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZSIsImF0dHJpYnV0ZU92ZXJyaWRlIiwibmV3QXR0cmlidXRlIiwic2V0QXR0cmlidXRlcyIsImlkIiwiZ2V0U2hhZGVycyIsImdlb21ldHJ5IiwiZHJhd01vZGUiLCJUUklBTkdMRVMiLCJ2ZXJ0ZXhQb3NpdGlvbnMiLCJpc0dlbmVyaWMiLCJ2YWx1ZSIsImlzU2lkZVZlcnRleCIsInZlcnRleENvdW50Iiwic2hhZGVyQ2FjaGUiLCJUUklBTkdMRV9TVFJJUCIsImlzaW5zdGFuY2VkIiwiTElORV9TVFJJUCIsImZpbHRlciIsIkJvb2xlYW4iLCJ0YXJnZXQiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImxlbmd0aCIsInBvbHlnb25JbmRleCIsImNvbG9ycyIsImtleSIsImdldENvbG9yIiwibGF5ZXJOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0JBOztBQUVBOztBQUdBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OzsrZUE3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0lBR09BLGtCLHNCQUFBQSxrQjtJQUFvQkMsRyxzQkFBQUEsRzs7QUFHM0I7O0FBT0EsSUFBTUMsbUJBQW1CLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLENBQXpCO0FBQ0EsSUFBTUMsbUJBQW1CLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLENBQXpCOztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLFVBQVEsSUFEVztBQUVuQjtBQUNBQyxZQUFVLEtBSFM7QUFJbkI7QUFDQUMsYUFBVyxLQUxRO0FBTW5CQyxRQUFNLEtBTmE7O0FBUW5CO0FBQ0FDLGtCQUFnQixDQVRHOztBQVduQjtBQUNBQyxjQUFZO0FBQUEsV0FBS1QsSUFBSVUsQ0FBSixFQUFPLFNBQVAsS0FBcUJWLElBQUlVLENBQUosRUFBTyxzQkFBUCxD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S0FBTCxDQUFXeUQsSUFBWCxDQUFnQjJDLFlBQWhCLENBQXhCLENBQWhCO0FBQUE7QUFGMEMsT0FBcEMsQ0FBbEI7QUFJRDs7QUFFRDs7OzsyQ0FDdUJ2QixTLEVBQVc7QUFDaENBLGdCQUFVVyxLQUFWLEdBQWtCLEtBQUszRSxLQUFMLENBQVc4QyxpQkFBWCxDQUE2QmxFLGFBQTdCLEVBQWxCO0FBQ0Q7Ozs7OztrQkE5VWtCTSxpQjs7O0FBaVZyQkEsa0JBQWtCeUcsU0FBbEIsR0FBOEIsbUJBQTlCO0FBQ0F6RyxrQkFBa0JwQyxZQUFsQixHQUFpQ0EsWUFBakMiLCJmaWxlIjoic29saWQtcG9seWdvbi1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNLCBMYXllciwgZXhwZXJpbWVudGFsfSBmcm9tICdkZWNrLmdsJztcbmNvbnN0IHtlbmFibGU2NGJpdFN1cHBvcnQsIGdldH0gPSBleHBlcmltZW50YWw7XG5pbXBvcnQge0dMLCBNb2RlbCwgR2VvbWV0cnl9IGZyb20gJ2x1bWEuZ2wnO1xuXG4vLyBQb2x5Z29uIGdlb21ldHJ5IGdlbmVyYXRpb24gaXMgbWFuYWdlZCBieSB0aGUgcG9seWdvbiB0ZXNzZWxhdG9yXG5pbXBvcnQge1BvbHlnb25UZXNzZWxhdG9yfSBmcm9tICcuL3BvbHlnb24tdGVzc2VsYXRvcic7XG5cbmltcG9ydCB2cyBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHZzNjQgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG5cbmNvbnN0IGRlZmF1bHRMaW5lQ29sb3IgPSBbMHgwLCAweDAsIDB4MCwgMHhmZl07XG5jb25zdCBkZWZhdWx0RmlsbENvbG9yID0gWzB4MCwgMHgwLCAweDAsIDB4ZmZdO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGZpbGxlZDogdHJ1ZSxcbiAgLy8gV2hldGhlciB0byBleHRydWRlXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgLy8gV2hldGhlciB0byBkcmF3IGEgR0wuTElORVMgd2lyZWZyYW1lIG9mIHRoZSBwb2x5Z29uXG4gIHdpcmVmcmFtZTogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuXG4gIC8vIGVsZXZhdGlvbiBtdWx0aXBsaWVyXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuXG4gIC8vIEFjY2Vzc29yIGZvciBwb2x5Z29uIGdlb21ldHJ5XG4gIGdldFBvbHlnb246IGYgPT4gZ2V0KGYsICdwb2x5Z29uJykgfHwgZ2V0KGYsICdnZW9tZXRyeS5jb29yZGluYXRlcycpLFxuICAvLyBBY2Nlc3NvciBmb3IgZXh0cnVzaW9uIGhlaWdodFxuICBnZXRFbGV2YXRpb246IGYgPT4gZ2V0KGYsICdlbGV2YXRpb24nKSB8fCBnZXQoZiwgJ3Byb3BlcnRpZXMuaGVpZ2h0JykgfHwgMCxcbiAgLy8gQWNjZXNzb3IgZm9yIGNvbG9yc1xuICBnZXRGaWxsQ29sb3I6IGYgPT4gZ2V0KGYsICdmaWxsQ29sb3InKSB8fCBnZXQoZiwgJ3Byb3BlcnRpZXMuY29sb3InKSB8fCBkZWZhdWx0RmlsbENvbG9yLFxuICBnZXRMaW5lQ29sb3I6IGYgPT4gZ2V0KGYsICdsaW5lQ29sb3InKSB8fCBnZXQoZiwgJ3Byb3BlcnRpZXMuY29sb3InKSB8fCBkZWZhdWx0TGluZUNvbG9yLFxuXG4gIC8vIE9wdGlvbmFsIHNldHRpbmdzIGZvciAnbGlnaHRpbmcnIHNoYWRlciBtb2R1bGVcbiAgbGlnaHRTZXR0aW5nczoge1xuICAgIGxpZ2h0c1Bvc2l0aW9uOiBbLTEyMi40NSwgMzcuNzUsIDgwMDAsIC0xMjIuMCwgMzguMCwgNTAwMF0sXG4gICAgYW1iaWVudFJhdGlvOiAwLjA1LFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzIuMCwgMC4wLCAwLjAsIDAuMF0sXG4gICAgbnVtYmVyT2ZMaWdodHM6IDJcbiAgfVxufTtcblxuLy8gU2lkZSBtb2RlbCBhdHRyaWJ1dGVzXG5jb25zdCBTSURFX0ZJTExfUE9TSVRJT05TID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIC8vIHRvcCBsZWZ0IGNvcm5lclxuICAwLFxuICAxLFxuICAvLyBib3R0b20gbGVmdCBjb3JuZXJcbiAgMCxcbiAgMCxcbiAgLy8gdG9wIHJpZ2h0IGNvcm5lclxuICAxLFxuICAxLFxuICAvLyBib3R0b20gcmlnaHQgY29ybmVyXG4gIDEsXG4gIDBcbl0pO1xuY29uc3QgU0lERV9XSVJFX1BPU0lUSU9OUyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAvLyB0b3AgcmlnaHQgY29ybmVyXG4gIDEsXG4gIDEsXG4gIC8vIHRvcCBsZWZ0IGNvcm5lclxuICAwLFxuICAxLFxuICAvLyBib3R0b20gbGVmdCBjb3JuZXJcbiAgMCxcbiAgMCxcbiAgLy8gYm90dG9tIHJpZ2h0IGNvcm5lclxuICAxLFxuICAwXG5dKTtcblxuLy8gTW9kZWwgdHlwZXNcbmNvbnN0IEFUVFJJQlVURV9NQVBTID0ge1xuICBUT1A6IHtcbiAgICBpbmRpY2VzOiB7aW5zdGFuY2VkOiAwfSxcbiAgICBwb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IDB9LFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IDB9LFxuICAgIGVsZXZhdGlvbnM6IHtpbnN0YW5jZWQ6IDB9LFxuICAgIGZpbGxDb2xvcnM6IHtuYW1lOiAnY29sb3JzJywgaW5zdGFuY2VkOiAwfSxcbiAgICBwaWNraW5nQ29sb3JzOiB7aW5zdGFuY2VkOiAwfVxuICB9LFxuICBTSURFOiB7XG4gICAgcG9zaXRpb25zOiB7aW5zdGFuY2VkOiAxfSxcbiAgICBwb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiAxfSxcbiAgICBuZXh0UG9zaXRpb25zOiB7aW5zdGFuY2VkOiAxfSxcbiAgICBuZXh0UG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogMX0sXG4gICAgZWxldmF0aW9uczoge2luc3RhbmNlZDogMX0sXG4gICAgZmlsbENvbG9yczoge25hbWU6ICdjb2xvcnMnLCBpbnN0YW5jZWQ6IDF9LFxuICAgIHBpY2tpbmdDb2xvcnM6IHtpbnN0YW5jZWQ6IDF9XG4gIH0sXG4gIFdJUkU6IHtcbiAgICBwb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIG5leHRQb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiAxfSxcbiAgICBlbGV2YXRpb25zOiB7aW5zdGFuY2VkOiAxfSxcbiAgICBsaW5lQ29sb3JzOiB7bmFtZTogJ2NvbG9ycycsIGluc3RhbmNlZDogMX0sXG4gICAgcGlja2luZ0NvbG9yczoge2luc3RhbmNlZDogMX1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU29saWRQb2x5Z29uTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGdldFNoYWRlcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZTY0Yml0U3VwcG9ydCh0aGlzLnByb3BzKVxuICAgICAgPyB7dnM6IHZzNjQsIGZzLCBtb2R1bGVzOiBbJ3Byb2plY3Q2NCcsICdsaWdodGluZycsICdwaWNraW5nJ119XG4gICAgICA6IHt2cywgZnMsIG1vZHVsZXM6IFsnbGlnaHRpbmcnLCAncGlja2luZyddfTsgLy8gJ3Byb2plY3QnIG1vZHVsZSBhZGRlZCBieSBkZWZhdWx0LlxuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBJbmRleFR5cGU6IGdsLmdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheVxuICAgIH0pO1xuXG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBub0FsbG9jID0gdHJ1ZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGQoe1xuICAgICAgaW5kaWNlczoge3NpemU6IDEsIGlzSW5kZXhlZDogdHJ1ZSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluZGljZXMsIG5vQWxsb2N9LFxuICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgIHNpemU6IDMsXG4gICAgICAgIGFjY2Vzc29yOiBbJ2V4dHJ1ZGVkJywgJ2ZwNjQnXSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9ucyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIG5leHRQb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6IFsnZXh0cnVkZWQnLCAnZnA2NCddLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTmV4dFBvc2l0aW9ucyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIGVsZXZhdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgYWNjZXNzb3I6IFsnZXh0cnVkZWQnLCAnZ2V0RWxldmF0aW9uJ10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVFbGV2YXRpb25zLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgZmlsbENvbG9yczoge1xuICAgICAgICBhbGlhczogJ2NvbG9ycycsXG4gICAgICAgIHNpemU6IDQsXG4gICAgICAgIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgIGFjY2Vzc29yOiAnZ2V0RmlsbENvbG9yJyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUZpbGxDb2xvcnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBsaW5lQ29sb3JzOiB7XG4gICAgICAgIGFsaWFzOiAnY29sb3JzJyxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lQ29sb3InLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTGluZUNvbG9ycyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIHBpY2tpbmdDb2xvcnM6IHtzaXplOiAzLCB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycywgbm9BbGxvY31cbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZSh7cHJvcHMsIG9sZFByb3BzfSkge1xuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAmJiBwcm9wcy5jb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICAgICAgcG9zaXRpb25zNjR4eUxvdzoge3NpemU6IDIsIGFjY2Vzc29yOiAnZnA2NCcsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnNMb3d9LFxuICAgICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7c2l6ZTogMiwgYWNjZXNzb3I6ICdmcDY0JywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZU5leHRQb3NpdGlvbnNMb3d9XG4gICAgICAgIH0pO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIucmVtb3ZlKFsncG9zaXRpb25zNjR4eUxvdycsICduZXh0UG9zaXRpb25zNjR4eUxvdyddKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkcmF3KHt1bmlmb3Jtc30pIHtcbiAgICBjb25zdCB7ZXh0cnVkZWQsIGxpZ2h0U2V0dGluZ3MsIGVsZXZhdGlvblNjYWxlfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCByZW5kZXJVbmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAge1xuICAgICAgICBleHRydWRlZDogZXh0cnVkZWQgPyAxLjAgOiAwLjAsXG4gICAgICAgIGVsZXZhdGlvblNjYWxlXG4gICAgICB9LFxuICAgICAgbGlnaHRTZXR0aW5nc1xuICAgICk7XG5cbiAgICB0aGlzLnN0YXRlLm1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcbiAgICAgIG1vZGVsLnJlbmRlcihyZW5kZXJVbmlmb3Jtcyk7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpIHtcbiAgICBzdXBlci51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuXG4gICAgdGhpcy51cGRhdGVHZW9tZXRyeSh1cGRhdGVQYXJhbXMpO1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlKHVwZGF0ZVBhcmFtcyk7XG5cbiAgICBjb25zdCB7cHJvcHMsIG9sZFByb3BzfSA9IHVwZGF0ZVBhcmFtcztcblxuICAgIGNvbnN0IHJlZ2VuZXJhdGVNb2RlbHMgPVxuICAgICAgcHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCB8fFxuICAgICAgcHJvcHMuZmlsbGVkICE9PSBvbGRQcm9wcy5maWxsZWQgfHxcbiAgICAgIHByb3BzLmV4dHJ1ZGVkICE9PSBvbGRQcm9wcy5leHRydWRlZCB8fFxuICAgICAgcHJvcHMud2lyZWZyYW1lICE9PSBvbGRQcm9wcy53aXJlZnJhbWU7XG5cbiAgICBpZiAocmVnZW5lcmF0ZU1vZGVscykge1xuICAgICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBTZXQgYSBmbGFnIHRvIHNldCBhdHRyaWJ1dGVzIHRvIG5ldyBtb2RlbHNcbiAgICAgICAgICAgIG1vZGVsc0NoYW5nZWQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMuX2dldE1vZGVscyh0aGlzLmNvbnRleHQuZ2wpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmV4dHJ1ZGVkICE9PSBvbGRQcm9wcy5leHRydWRlZCkge1xuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGUoJ2V4dHJ1ZGVkJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnZnA2NCcpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUdlb21ldHJ5KHtwcm9wcywgb2xkUHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCA9XG4gICAgICBjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCB8fFxuICAgICAgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCAmJlxuICAgICAgICAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmFsbCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuZ2V0UG9seWdvbikpO1xuXG4gICAgLy8gV2hlbiB0aGUgZ2VvbWV0cnkgY29uZmlnICBvciB0aGUgZGF0YSBpcyBjaGFuZ2VkLFxuICAgIC8vIHRlc3NlbGxhdG9yIG5lZWRzIHRvIGJlIGludm9rZWRcbiAgICBpZiAoZ2VvbWV0cnlDb25maWdDaGFuZ2VkKSB7XG4gICAgICAvLyBUT0RPIC0gYXZvaWQgY3JlYXRpbmcgYSB0ZW1wb3JhcnkgYXJyYXkgaGVyZTogbGV0IHRoZSB0ZXNzZWxhdG9yIGl0ZXJhdGVcbiAgICAgIGNvbnN0IHBvbHlnb25zID0gcHJvcHMuZGF0YS5tYXAocHJvcHMuZ2V0UG9seWdvbik7XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwb2x5Z29uVGVzc2VsYXRvcjogbmV3IFBvbHlnb25UZXNzZWxhdG9yKHtwb2x5Z29ucywgSW5kZXhUeXBlOiB0aGlzLnN0YXRlLkluZGV4VHlwZX0pXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zdGF0ZS5hdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBnZW9tZXRyeUNvbmZpZ0NoYW5nZWQgfHxcbiAgICAgIHByb3BzLmV4dHJ1ZGVkICE9PSBvbGRQcm9wcy5leHRydWRlZCB8fFxuICAgICAgcHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NFxuICAgICkge1xuICAgICAgdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci51cGRhdGVQb3NpdGlvbnMoe1xuICAgICAgICBmcDY0OiBwcm9wcy5mcDY0LFxuICAgICAgICBleHRydWRlZDogcHJvcHMuZXh0cnVkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlciwgbW9kZWxzQ2hhbmdlZH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgLy8gRmlndXJlIG91dCBkYXRhIGxlbmd0aFxuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBwcm9wcyxcbiAgICAgIGJ1ZmZlcnM6IHByb3BzLFxuICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIC8vIERvbid0IHdvcnJ5IGFib3V0IG5vbi1hdHRyaWJ1dGUgcHJvcHNcbiAgICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAobW9kZWxzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVNYW5hZ2VyLmF0dHJpYnV0ZXMpO1xuICAgICAgLy8gY2xlYXIgdGhlIGZsYWdcbiAgICAgIHRoaXMuc2V0U3RhdGUoe21vZGVsc0NoYW5nZWQ6IGZhbHNlfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWV9KTtcbiAgICAgIHRoaXMuX3VwZGF0ZUF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB7bW9kZWxzQnlOYW1lfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsTmFtZSBpbiBtb2RlbHNCeU5hbWUpIHtcbiAgICAgIGNvbnN0IG1vZGVsID0gbW9kZWxzQnlOYW1lW21vZGVsTmFtZV07XG5cbiAgICAgIGlmIChtb2RlbE5hbWUgPT09ICdUT1AnKSB7XG4gICAgICAgIG1vZGVsLnNldFZlcnRleENvdW50KHRoaXMuc3RhdGUubnVtVmVydGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5zdGF0ZS5udW1JbnN0YW5jZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVNYXAgPSBBVFRSSUJVVEVfTUFQU1ttb2RlbE5hbWVdO1xuICAgICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlT3ZlcnJpZGUgPSBhdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgY29uc3QgbmV3QXR0cmlidXRlID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlLCBhdHRyaWJ1dGVPdmVycmlkZSk7XG4gICAgICAgICAgbmV3QXR0cmlidXRlc1thdHRyaWJ1dGVPdmVycmlkZS5uYW1lIHx8IGF0dHJpYnV0ZU5hbWVdID0gbmV3QXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKG5ld0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRNb2RlbHMoZ2wpIHtcbiAgICBjb25zdCB7aWQsIGZpbGxlZCwgZXh0cnVkZWQsIHdpcmVmcmFtZX0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgbW9kZWxzID0ge307XG5cbiAgICBpZiAoZmlsbGVkKSB7XG4gICAgICBtb2RlbHMuVE9QID0gbmV3IE1vZGVsKFxuICAgICAgICBnbCxcbiAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgICBpZDogYCR7aWR9LXRvcGAsXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVTLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtzaXplOiAyLCBpc0dlbmVyaWM6IHRydWUsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFswLCAxXSl9LFxuICAgICAgICAgICAgICBuZXh0UG9zaXRpb25zOiB7c2l6ZTogMywgaXNHZW5lcmljOiB0cnVlLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgzKX0sXG4gICAgICAgICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7c2l6ZTogMiwgaXNHZW5lcmljOiB0cnVlLCB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheSgyKX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgaXNTaWRlVmVydGV4OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZXJ0ZXhDb3VudDogMCxcbiAgICAgICAgICBpc0luZGV4ZWQ6IHRydWUsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZpbGxlZCAmJiBleHRydWRlZCkge1xuICAgICAgbW9kZWxzLlNJREUgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0tc2lkZWAsXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogR0wuVFJJQU5HTEVfU1RSSVAsXG4gICAgICAgICAgICB2ZXJ0ZXhDb3VudDogNCxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb25zOiB7c2l6ZTogMiwgdmFsdWU6IFNJREVfRklMTF9QT1NJVElPTlN9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIGlzU2lkZVZlcnRleDogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNpbnN0YW5jZWQ6IDEsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGV4dHJ1ZGVkICYmIHdpcmVmcmFtZSkge1xuICAgICAgbW9kZWxzLldJUkUgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0td2lyZWAsXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogR0wuTElORV9TVFJJUCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiA0LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtzaXplOiAyLCB2YWx1ZTogU0lERV9XSVJFX1BPU0lUSU9OU31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgaXNTaWRlVmVydGV4OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc2luc3RhbmNlZDogMSxcbiAgICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtb2RlbHM6IFttb2RlbHMuV0lSRSwgbW9kZWxzLlNJREUsIG1vZGVscy5UT1BdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgIG1vZGVsc0J5TmFtZTogbW9kZWxzXG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5pbmRpY2VzKCk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIGNvbnN0IG51bVZlcnRleCA9IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtudW1WZXJ0ZXh9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBvc2l0aW9ucygpO1xuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggLyBhdHRyaWJ1dGUuc2l6ZTtcbiAgICB0aGlzLnNldFN0YXRlKHtudW1JbnN0YW5jZXN9KTtcbiAgfVxuICBjYWxjdWxhdGVQb3NpdGlvbnNMb3coYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5wb3NpdGlvbnM2NHh5TG93KCk7XG4gIH1cblxuICBjYWxjdWxhdGVOZXh0UG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IubmV4dFBvc2l0aW9ucygpO1xuICB9XG4gIGNhbGN1bGF0ZU5leHRQb3NpdGlvbnNMb3coYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5uZXh0UG9zaXRpb25zNjR4eUxvdygpO1xuICB9XG5cbiAgY2FsY3VsYXRlRWxldmF0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5leHRydWRlZCkge1xuICAgICAgYXR0cmlidXRlLmlzR2VuZXJpYyA9IGZhbHNlO1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5lbGV2YXRpb25zKHtcbiAgICAgICAgZ2V0RWxldmF0aW9uOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRFbGV2YXRpb24odGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlLmlzR2VuZXJpYyA9IHRydWU7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZUZpbGxDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5jb2xvcnMoe1xuICAgICAga2V5OiAnZmlsbENvbG9ycycsXG4gICAgICBnZXRDb2xvcjogcG9seWdvbkluZGV4ID0+IHRoaXMucHJvcHMuZ2V0RmlsbENvbG9yKHRoaXMucHJvcHMuZGF0YVtwb2x5Z29uSW5kZXhdKVxuICAgIH0pO1xuICB9XG4gIGNhbGN1bGF0ZUxpbmVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5jb2xvcnMoe1xuICAgICAga2V5OiAnbGluZUNvbG9ycycsXG4gICAgICBnZXRDb2xvcjogcG9seWdvbkluZGV4ID0+IHRoaXMucHJvcHMuZ2V0TGluZUNvbG9yKHRoaXMucHJvcHMuZGF0YVtwb2x5Z29uSW5kZXhdKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgcGlja2luZyBjb2xvcnMgY2FsY3VsYXRpb25cbiAgY2FsY3VsYXRlUGlja2luZ0NvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBpY2tpbmdDb2xvcnMoKTtcbiAgfVxufVxuXG5Tb2xpZFBvbHlnb25MYXllci5sYXllck5hbWUgPSAnU29saWRQb2x5Z29uTGF5ZXInO1xuU29saWRQb2x5Z29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19