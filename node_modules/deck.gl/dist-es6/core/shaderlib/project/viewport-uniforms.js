// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import mat4_multiply from 'gl-mat4/multiply';
import vec4_transformMat4 from 'gl-vec4/transformMat4';

import log from '../../utils/log';
import assert from 'assert';
import { COORDINATE_SYSTEM } from '../../lib/constants';

import { lngLatToWorld } from 'viewport-mercator-project';

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];

// TODO - import these utils from fp64 package
function fp64ify(a) {
  var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  array[startIndex] = hiPart;
  array[startIndex + 1] = loPart;
  return array;
}

// calculate WebGL 64 bit matrix (transposed "Float64Array")
function fp64ifyMatrix4(matrix) {
  // Transpose the projection matrix to column major for GLSL.
  var matrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref) {
  var viewport = _ref.viewport,
      modelMatrix = _ref.modelMatrix,
      coordinateSystem = _ref.coordinateSystem,
      coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;

  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.IDENTITY:
    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      break;

    // TODO: make lighting work for meter offset mode
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
    case COORDINATE_SYSTEM.METER_OFFSETS:
      // Calculate transformed projectionCenter (using 64 bit precision JS)
      // This is the key to offset mode precision
      // (avoids doing this addition in 32 bit precision in GLSL)
      var positionPixels = lngLatToWorld(coordinateOrigin, Math.pow(2, coordinateZoom));
      // projectionCenter = new Matrix4(viewProjectionMatrix)
      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
      projectionCenter = vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);

      // Always apply uncentered projection matrix if available (shader adds center)
      viewMatrix = viewMatrixUncentered || viewMatrix;

      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = mat4_multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: viewport.cameraPosition
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref2.viewport,
      _ref2$modelMatrix = _ref2.modelMatrix,
      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,
      _ref2$coordinateSyste = _ref2.coordinateSystem,
      coordinateSystem = _ref2$coordinateSyste === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
      coordinateOrigin = _ref2$coordinateOrigi === undefined ? [0, 0] : _ref2$coordinateOrigi,
      _ref2$fp = _ref2.fp64,
      fp64 = _ref2$fp === undefined ? false : _ref2$fp,
      projectionMode = _ref2.projectionMode,
      positionOrigin = _ref2.positionOrigin;

  assert(viewport);

  if (projectionMode !== undefined) {
    log.removed('projectionMode', 'coordinateSystem');
  }
  if (positionOrigin !== undefined) {
    log.removed('positionOrigin', 'coordinateOrigin');
  }

  var coordinateZoom = viewport.zoom;
  assert(coordinateZoom >= 0);

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem,
    coordinateOrigin: coordinateOrigin,
    coordinateZoom: coordinateZoom,
    modelMatrix: modelMatrix,
    viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var distanceScales = viewport.getDistanceScales();

  // TODO - does this depend on useDevicePixels?
  var devicePixelRatio = window && window.devicePixelRatio || 1;
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];

  var glModelMatrix = modelMatrix || IDENTITY_MATRIX;

  var uniforms = {
    // Projection mode values
    project_uCoordinateSystem: coordinateSystem,
    project_uCenter: projectionCenter,

    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,

    // Distance at which screen pixels are projected
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,
    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,
    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)

    project_uModelMatrix: glModelMatrix,
    project_uViewProjectionMatrix: viewProjectionMatrix,

    // This is for lighting calculations
    project_uCameraPosition: cameraPos
  };

  if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    var distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);
    uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;
    uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
  }
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
    var _distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);
    uniforms.project_uPixelsPerUnit = _distanceScalesAtOrigin.pixelsPerDegree;
    uniforms.project_uPixelsPerUnit2 = _distanceScalesAtOrigin.pixelsPerDegree2;
  }

  // TODO - fp64 flag should be from shader module, not layer props
  return fp64 ? addFP64Uniforms(uniforms) : uniforms;
}

// 64 bit projection support
function addFP64Uniforms(uniforms) {
  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(uniforms.project_uViewProjectionMatrix);
  var scaleFP64 = fp64ify(uniforms.project_uScale);

  uniforms.project_uViewProjectionMatrixFP64 = glViewProjectionMatrixFP64;
  uniforms.project64_uViewProjectionMatrix = glViewProjectionMatrixFP64;
  uniforms.project64_uScale = scaleFP64;

  return uniforms;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9wcm9qZWN0L3ZpZXdwb3J0LXVuaWZvcm1zLmpzIl0sIm5hbWVzIjpbIm1hdDRfbXVsdGlwbHkiLCJ2ZWM0X3RyYW5zZm9ybU1hdDQiLCJsb2ciLCJhc3NlcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsImxuZ0xhdFRvV29ybGQiLCJaRVJPX1ZFQ1RPUiIsIlZFQ1RPUl9UT19QT0lOVF9NQVRSSVgiLCJJREVOVElUWV9NQVRSSVgiLCJERUZBVUxUX1BJWEVMU19QRVJfVU5JVDIiLCJmcDY0aWZ5IiwiYSIsImFycmF5Iiwic3RhcnRJbmRleCIsImhpUGFydCIsIk1hdGgiLCJmcm91bmQiLCJsb1BhcnQiLCJmcDY0aWZ5TWF0cml4NCIsIm1hdHJpeCIsIm1hdHJpeEZQNjQiLCJGbG9hdDMyQXJyYXkiLCJpIiwiaiIsImluZGV4IiwiY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0Iiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsImNvb3JkaW5hdGVTeXN0ZW0iLCJjb29yZGluYXRlT3JpZ2luIiwiY29vcmRpbmF0ZVpvb20iLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0aW9uQ2VudGVyIiwiSURFTlRJVFkiLCJMTkdMQVQiLCJMTkdMQVRfT0ZGU0VUUyIsIk1FVEVSX09GRlNFVFMiLCJwb3NpdGlvblBpeGVscyIsInBvdyIsIkVycm9yIiwiY2FtZXJhUG9zIiwiY2FtZXJhUG9zaXRpb24iLCJnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCIsImZwNjQiLCJwcm9qZWN0aW9uTW9kZSIsInBvc2l0aW9uT3JpZ2luIiwidW5kZWZpbmVkIiwicmVtb3ZlZCIsInpvb20iLCJkaXN0YW5jZVNjYWxlcyIsImdldERpc3RhbmNlU2NhbGVzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsInZpZXdwb3J0U2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2xNb2RlbE1hdHJpeCIsInVuaWZvcm1zIiwicHJvamVjdF91Q29vcmRpbmF0ZVN5c3RlbSIsInByb2plY3RfdUNlbnRlciIsInByb2plY3RfdVZpZXdwb3J0U2l6ZSIsInByb2plY3RfdURldmljZVBpeGVsUmF0aW8iLCJwcm9qZWN0X3VGb2NhbERpc3RhbmNlIiwiZm9jYWxEaXN0YW5jZSIsInByb2plY3RfdVBpeGVsc1Blck1ldGVyIiwicGl4ZWxzUGVyTWV0ZXIiLCJwcm9qZWN0X3VQaXhlbHNQZXJEZWdyZWUiLCJwaXhlbHNQZXJEZWdyZWUiLCJwcm9qZWN0X3VQaXhlbHNQZXJVbml0IiwicHJvamVjdF91UGl4ZWxzUGVyVW5pdDIiLCJwcm9qZWN0X3VTY2FsZSIsInNjYWxlIiwicHJvamVjdF91TW9kZWxNYXRyaXgiLCJwcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3RfdUNhbWVyYVBvc2l0aW9uIiwiZGlzdGFuY2VTY2FsZXNBdE9yaWdpbiIsInBpeGVsc1Blck1ldGVyMiIsInBpeGVsc1BlckRlZ3JlZTIiLCJhZGRGUDY0VW5pZm9ybXMiLCJnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCIsInNjYWxlRlA2NCIsInByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCIsInByb2plY3Q2NF91Vmlld1Byb2plY3Rpb25NYXRyaXgiLCJwcm9qZWN0NjRfdVNjYWxlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU9BLGFBQVAsTUFBMEIsa0JBQTFCO0FBQ0EsT0FBT0Msa0JBQVAsTUFBK0IsdUJBQS9COztBQUVBLE9BQU9DLEdBQVAsTUFBZ0IsaUJBQWhCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjtBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLHFCQUFoQzs7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LFNBQVNnRCxLQWZWLEVBZWlCOztBQUVoQ0MsMEJBQXNCaEIsYUFqQlA7QUFrQmZpQixtQ0FBK0IxQyxvQkFsQmhCOztBQW9CZjtBQUNBMkMsNkJBQXlCbEM7QUFyQlYsR0FBakI7O0FBd0JBLE1BQUlmLHFCQUFxQnhCLGtCQUFrQm1DLGFBQTNDLEVBQTBEO0FBQ3hELFFBQU11Qyx5QkFBeUJwRCxTQUFTMkIsaUJBQVQsQ0FBMkJ4QixnQkFBM0IsQ0FBL0I7QUFDQStCLGFBQVNXLHNCQUFULEdBQWtDTyx1QkFBdUJWLGNBQXpEO0FBQ0FSLGFBQVNZLHVCQUFULEdBQW1DTSx1QkFBdUJDLGVBQTFEO0FBQ0Q7QUFDRCxNQUFJbkQscUJBQXFCeEIsa0JBQWtCa0MsY0FBM0MsRUFBMkQ7QUFDekQsUUFBTXdDLDBCQUF5QnBELFNBQVMyQixpQkFBVCxDQUEyQnhCLGdCQUEzQixDQUEvQjtBQUNBK0IsYUFBU1csc0JBQVQsR0FBa0NPLHdCQUF1QlIsZUFBekQ7QUFDQVYsYUFBU1ksdUJBQVQsR0FBbUNNLHdCQUF1QkUsZ0JBQTFEO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFPbEMsT0FBT21DLGdCQUFnQnJCLFFBQWhCLENBQVAsR0FBbUNBLFFBQTFDO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTcUIsZUFBVCxDQUF5QnJCLFFBQXpCLEVBQW1DO0FBQ2pDLE1BQU1zQiw2QkFBNkJoRSxlQUFlMEMsU0FBU2dCLDZCQUF4QixDQUFuQztBQUNBLE1BQU1PLFlBQVl6RSxRQUFRa0QsU0FBU2EsY0FBakIsQ0FBbEI7O0FBRUFiLFdBQVN3QixpQ0FBVCxHQUE2Q0YsMEJBQTdDO0FBQ0F0QixXQUFTeUIsK0JBQVQsR0FBMkNILDBCQUEzQztBQUNBdEIsV0FBUzBCLGdCQUFULEdBQTRCSCxTQUE1Qjs7QUFFQSxTQUFPdkIsUUFBUDtBQUNEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBtYXQ0X211bHRpcGx5IGZyb20gJ2dsLW1hdDQvbXVsdGlwbHknO1xuaW1wb3J0IHZlYzRfdHJhbnNmb3JtTWF0NCBmcm9tICdnbC12ZWM0L3RyYW5zZm9ybU1hdDQnO1xuXG5pbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi9saWIvY29uc3RhbnRzJztcblxuaW1wb3J0IHtsbmdMYXRUb1dvcmxkfSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuLy8gVG8gcXVpY2tseSBzZXQgYSB2ZWN0b3IgdG8gemVyb1xuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMCwgMF07XG4vLyA0eDQgbWF0cml4IHRoYXQgZHJvcHMgNHRoIGNvbXBvbmVudCBvZiB2ZWN0b3JcbmNvbnN0IFZFQ1RPUl9UT19QT0lOVF9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMF07XG5jb25zdCBJREVOVElUWV9NQVRSSVggPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5jb25zdCBERUZBVUxUX1BJWEVMU19QRVJfVU5JVDIgPSBbMCwgMCwgMF07XG5cbi8vIFRPRE8gLSBpbXBvcnQgdGhlc2UgdXRpbHMgZnJvbSBmcDY0IHBhY2thZ2VcbmZ1bmN0aW9uIGZwNjRpZnkoYSwgYXJyYXkgPSBbXSwgc3RhcnRJbmRleCA9IDApIHtcbiAgY29uc3QgaGlQYXJ0ID0gTWF0aC5mcm91bmQoYSk7XG4gIGNvbnN0IGxvUGFydCA9IGEgLSBoaVBhcnQ7XG4gIGFycmF5W3N0YXJ0SW5kZXhdID0gaGlQYXJ0O1xuICBhcnJheVtzdGFydEluZGV4ICsgMV0gPSBsb1BhcnQ7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gY2FsY3VsYXRlIFdlYkdMIDY0IGJpdCBtYXRyaXggKHRyYW5zcG9zZWQgXCJGbG9hdDY0QXJyYXlcIilcbmZ1bmN0aW9uIGZwNjRpZnlNYXRyaXg0KG1hdHJpeCkge1xuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgbWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0ICsgajtcbiAgICAgIGZwNjRpZnkobWF0cml4W2ogKiA0ICsgaV0sIG1hdHJpeEZQNjQsIGluZGV4ICogMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRyaXhGUDY0O1xufVxuXG4vLyBUaGUgY29kZSB0aGF0IHV0aWxpemVzIE1hdHJpeDQgZG9lcyB0aGUgc2FtZSBjYWxjdWxhdGlvbiBhcyB0aGVpciBtYXQ0IGNvdW50ZXJwYXJ0cyxcbi8vIGhhcyBsb3dlciBwZXJmb3JtYW5jZSBidXQgcHJvdmlkZXMgZXJyb3IgY2hlY2tpbmcuXG4vLyBVbmNvbW1lbnQgd2hlbiBkZWJ1Z2dpbmdcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7XG4gIC8vIFVOQ0hBTkdFRFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXgsXG4gIC8vIE5FVyBQQVJBTVNcbiAgY29vcmRpbmF0ZVN5c3RlbSxcbiAgY29vcmRpbmF0ZU9yaWdpbixcbiAgY29vcmRpbmF0ZVpvb21cbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkfSA9IHZpZXdwb3J0O1xuICBsZXQge3ZpZXdNYXRyaXh9ID0gdmlld3BvcnQ7XG4gIGNvbnN0IHtwcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuICBsZXQge3ZpZXdQcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuXG4gIHN3aXRjaCAoY29vcmRpbmF0ZVN5c3RlbSkge1xuICAgIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uSURFTlRJVFk6XG4gICAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgICBwcm9qZWN0aW9uQ2VudGVyID0gWkVST19WRUNUT1I7XG4gICAgICBicmVhaztcblxuICAgIC8vIFRPRE86IG1ha2UgbGlnaHRpbmcgd29yayBmb3IgbWV0ZXIgb2Zmc2V0IG1vZGVcbiAgICBjYXNlIENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVF9PRkZTRVRTOlxuICAgIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICAgIC8vIENhbGN1bGF0ZSB0cmFuc2Zvcm1lZCBwcm9qZWN0aW9uQ2VudGVyICh1c2luZyA2NCBiaXQgcHJlY2lzaW9uIEpTKVxuICAgICAgLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvblxuICAgICAgLy8gKGF2b2lkcyBkb2luZyB0aGlzIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24gaW4gR0xTTClcbiAgICAgIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gbG5nTGF0VG9Xb3JsZChjb29yZGluYXRlT3JpZ2luLCBNYXRoLnBvdygyLCBjb29yZGluYXRlWm9vbSkpO1xuICAgICAgLy8gcHJvamVjdGlvbkNlbnRlciA9IG5ldyBNYXRyaXg0KHZpZXdQcm9qZWN0aW9uTWF0cml4KVxuICAgICAgLy8gICAudHJhbnNmb3JtVmVjdG9yKFtwb3NpdGlvblBpeGVsc1swXSwgcG9zaXRpb25QaXhlbHNbMV0sIDAuMCwgMS4wXSk7XG4gICAgICBwcm9qZWN0aW9uQ2VudGVyID0gdmVjNF90cmFuc2Zvcm1NYXQ0KFxuICAgICAgICBbXSxcbiAgICAgICAgW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdLFxuICAgICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeFxuICAgICAgKTtcblxuICAgICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgICB2aWV3TWF0cml4ID0gdmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeDtcblxuICAgICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgICAvLyB2aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAgIC8vICAgLm11bHRpcGx5UmlnaHQoVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpO1xuICAgICAgdmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB2aWV3UHJvamVjdGlvbk1hdHJpeCwgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXgsXG4gICAgdmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcbiAgICBjYW1lcmFQb3M6IHZpZXdwb3J0LmNhbWVyYVBvc2l0aW9uXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh7XG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIGNvb3JkaW5hdGVTeXN0ZW0gPSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIGNvb3JkaW5hdGVPcmlnaW4gPSBbMCwgMF0sXG4gIGZwNjQgPSBmYWxzZSxcbiAgLy8gRGVwcmVjYXRlZFxuICBwcm9qZWN0aW9uTW9kZSxcbiAgcG9zaXRpb25PcmlnaW5cbn0gPSB7fSkge1xuICBhc3NlcnQodmlld3BvcnQpO1xuXG4gIGlmIChwcm9qZWN0aW9uTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbG9nLnJlbW92ZWQoJ3Byb2plY3Rpb25Nb2RlJywgJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgfVxuICBpZiAocG9zaXRpb25PcmlnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGxvZy5yZW1vdmVkKCdwb3NpdGlvbk9yaWdpbicsICdjb29yZGluYXRlT3JpZ2luJyk7XG4gIH1cblxuICBjb25zdCBjb29yZGluYXRlWm9vbSA9IHZpZXdwb3J0Lnpvb207XG4gIGFzc2VydChjb29yZGluYXRlWm9vbSA+PSAwKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgdmlld1Byb2plY3Rpb25NYXRyaXgsIGNhbWVyYVBvc30gPSBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe1xuICAgIGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgY29vcmRpbmF0ZU9yaWdpbixcbiAgICBjb29yZGluYXRlWm9vbSxcbiAgICBtb2RlbE1hdHJpeCxcbiAgICB2aWV3cG9ydFxuICB9KTtcblxuICBhc3NlcnQodmlld1Byb2plY3Rpb25NYXRyaXgsICdWaWV3cG9ydCBtaXNzaW5nIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgnKTtcblxuICAvLyBDYWxjdWxhdGUgcHJvamVjdGlvbiBwaXhlbHMgcGVyIHVuaXRcbiAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcygpO1xuXG4gIC8vIFRPRE8gLSBkb2VzIHRoaXMgZGVwZW5kIG9uIHVzZURldmljZVBpeGVscz9cbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9ICh3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG4gIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IFt2aWV3cG9ydC53aWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHZpZXdwb3J0LmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9dO1xuXG4gIGNvbnN0IGdsTW9kZWxNYXRyaXggPSBtb2RlbE1hdHJpeCB8fCBJREVOVElUWV9NQVRSSVg7XG5cbiAgY29uc3QgdW5pZm9ybXMgPSB7XG4gICAgLy8gUHJvamVjdGlvbiBtb2RlIHZhbHVlc1xuICAgIHByb2plY3RfdUNvb3JkaW5hdGVTeXN0ZW06IGNvb3JkaW5hdGVTeXN0ZW0sXG4gICAgcHJvamVjdF91Q2VudGVyOiBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgLy8gU2NyZWVuIHNpemVcbiAgICBwcm9qZWN0X3VWaWV3cG9ydFNpemU6IHZpZXdwb3J0U2l6ZSxcbiAgICBwcm9qZWN0X3VEZXZpY2VQaXhlbFJhdGlvOiBkZXZpY2VQaXhlbFJhdGlvLFxuXG4gICAgLy8gRGlzdGFuY2UgYXQgd2hpY2ggc2NyZWVuIHBpeGVscyBhcmUgcHJvamVjdGVkXG4gICAgcHJvamVjdF91Rm9jYWxEaXN0YW5jZTogdmlld3BvcnQuZm9jYWxEaXN0YW5jZSB8fCAxLFxuICAgIHByb2plY3RfdVBpeGVsc1Blck1ldGVyOiBkaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcixcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJEZWdyZWU6IGRpc3RhbmNlU2NhbGVzLnBpeGVsc1BlckRlZ3JlZSxcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJVbml0OiBkaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcixcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJVbml0MjogREVGQVVMVF9QSVhFTFNfUEVSX1VOSVQyLFxuICAgIHByb2plY3RfdVNjYWxlOiB2aWV3cG9ydC5zY2FsZSwgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcblxuICAgIHByb2plY3RfdU1vZGVsTWF0cml4OiBnbE1vZGVsTWF0cml4LFxuICAgIHByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4OiB2aWV3UHJvamVjdGlvbk1hdHJpeCxcblxuICAgIC8vIFRoaXMgaXMgZm9yIGxpZ2h0aW5nIGNhbGN1bGF0aW9uc1xuICAgIHByb2plY3RfdUNhbWVyYVBvc2l0aW9uOiBjYW1lcmFQb3NcbiAgfTtcblxuICBpZiAoY29vcmRpbmF0ZVN5c3RlbSA9PT0gQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUykge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcyhjb29yZGluYXRlT3JpZ2luKTtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0ID0gZGlzdGFuY2VTY2FsZXNBdE9yaWdpbi5waXhlbHNQZXJNZXRlcjtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0MiA9IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4ucGl4ZWxzUGVyTWV0ZXIyO1xuICB9XG4gIGlmIChjb29yZGluYXRlU3lzdGVtID09PSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVRfT0ZGU0VUUykge1xuICAgIGNvbnN0IGRpc3RhbmNlU2NhbGVzQXRPcmlnaW4gPSB2aWV3cG9ydC5nZXREaXN0YW5jZVNjYWxlcyhjb29yZGluYXRlT3JpZ2luKTtcbiAgICB1bmlmb3Jtcy5wcm9qZWN0X3VQaXhlbHNQZXJVbml0ID0gZGlzdGFuY2VTY2FsZXNBdE9yaWdpbi5waXhlbHNQZXJEZWdyZWU7XG4gICAgdW5pZm9ybXMucHJvamVjdF91UGl4ZWxzUGVyVW5pdDIgPSBkaXN0YW5jZVNjYWxlc0F0T3JpZ2luLnBpeGVsc1BlckRlZ3JlZTI7XG4gIH1cblxuICAvLyBUT0RPIC0gZnA2NCBmbGFnIHNob3VsZCBiZSBmcm9tIHNoYWRlciBtb2R1bGUsIG5vdCBsYXllciBwcm9wc1xuICByZXR1cm4gZnA2NCA/IGFkZEZQNjRVbmlmb3Jtcyh1bmlmb3JtcykgOiB1bmlmb3Jtcztcbn1cblxuLy8gNjQgYml0IHByb2plY3Rpb24gc3VwcG9ydFxuZnVuY3Rpb24gYWRkRlA2NFVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gIGNvbnN0IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0ID0gZnA2NGlmeU1hdHJpeDQodW5pZm9ybXMucHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXgpO1xuICBjb25zdCBzY2FsZUZQNjQgPSBmcDY0aWZ5KHVuaWZvcm1zLnByb2plY3RfdVNjYWxlKTtcblxuICB1bmlmb3Jtcy5wcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQgPSBnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NDtcbiAgdW5pZm9ybXMucHJvamVjdDY0X3VWaWV3UHJvamVjdGlvbk1hdHJpeCA9IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0O1xuICB1bmlmb3Jtcy5wcm9qZWN0NjRfdVNjYWxlID0gc2NhbGVGUDY0O1xuXG4gIHJldHVybiB1bmlmb3Jtcztcbn1cbiJdfQ==