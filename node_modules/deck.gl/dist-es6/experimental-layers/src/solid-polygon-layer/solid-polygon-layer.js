var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { COORDINATE_SYSTEM, Layer, experimental } from 'deck.gl';
var enable64bitSupport = experimental.enable64bitSupport,
    get = experimental.get;

import { GL, Model, Geometry } from 'luma.gl';

// Polygon geometry generation is managed by the polygon tesselator
import { PolygonTesselator } from './polygon-tesselator';

import vs from './solid-polygon-layer-vertex.glsl';
import vs64 from './solid-polygon-layer-vertex-64.glsl';
import fs from './solid-polygon-layer-fragment.glsl';

var defaultLineColor = [0x0, 0x0, 0x0, 0xff];
var defaultFillColor = [0x0, 0x0, 0x0, 0xff];

var defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // elevation multiplier
  elevationScale: 1,

  // Accessor for polygon geometry
  getPolygon: function getPolygon(f) {
    return get(f, 'polygon') || get(f, 'geometry.coordinates');
  },
  // Accessor for extrusion height
  getElevation: function getElevation(f) {
    return get(f, 'elevation') || get(f, 'properties.height') || 0;
  },
  // Accessor for colors
  getFillColor: function getFillColor(f) {
    return get(f, 'fillColor') || get(f, 'properties.color') || defaultFillColor;
  },
  getLineColor: function getLineColor(f) {
    return get(f, 'lineColor') || get(f, 'properties.color') || defaultLineColor;
  },

  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.0, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

// Side model attributes
var SIDE_FILL_POSITIONS = new Float32Array([
// top left corner
0, 1,
// bottom left corner
0, 0,
// top right corner
1, 1,
// bottom right corner
1, 0]);
var SIDE_WIRE_POSITIONS = new Float32Array([
// top right corner
1, 1,
// top left corner
0, 1,
// bottom left corner
0, 0,
// bottom right corner
1, 0]);

// Model types
var ATTRIBUTE_MAPS = {
  TOP: {
    indices: { instanced: 0 },
    positions: { instanced: 0 },
    positions64xyLow: { instanced: 0 },
    elevations: { instanced: 0 },
    fillColors: { name: 'colors', instanced: 0 },
    pickingColors: { instanced: 0 }
  },
  SIDE: {
    positions: { instanced: 1 },
    positions64xyLow: { instanced: 1 },
    nextPositions: { instanced: 1 },
    nextPositions64xyLow: { instanced: 1 },
    elevations: { instanced: 1 },
    fillColors: { name: 'colors', instanced: 1 },
    pickingColors: { instanced: 1 }
  },
  WIRE: {
    positions: { instanced: 1 },
    positions64xyLow: { instanced: 1 },
    nextPositions: { instanced: 1 },
    nextPositions64xyLow: { instanced: 1 },
    elevations: { instanced: 1 },
    lineColors: { name: 'colors', instanced: 1 },
    pickingColors: { instanced: 1 }
  }
};

var SolidPolygonLayer = function (_Layer) {
  _inherits(SolidPolygonLayer, _Layer);

  function SolidPolygonLayer() {
    _classCallCheck(this, SolidPolygonLayer);

    return _possibleConstructorReturn(this, (SolidPolygonLayer.__proto__ || Object.getPrototypeOf(SolidPolygonLayer)).apply(this, arguments));
  }

  _createClass(SolidPolygonLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return enable64bitSupport(this.props) ? { vs: vs64, fs: fs, modules: ['project64', 'lighting', 'picking'] } : { vs: vs, fs: fs, modules: ['lighting', 'picking'] }; // 'project' module added by default.
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;

      this.setState({
        numInstances: 0,
        IndexType: gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array
      });

      var attributeManager = this.state.attributeManager;

      var noAlloc = true;
      /* eslint-disable max-len */
      attributeManager.add({
        indices: { size: 1, isIndexed: true, update: this.calculateIndices, noAlloc: noAlloc },
        positions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculatePositions,
          noAlloc: noAlloc
        },
        nextPositions: {
          size: 3,
          accessor: ['extruded', 'fp64'],
          update: this.calculateNextPositions,
          noAlloc: noAlloc
        },
        elevations: {
          size: 1,
          accessor: ['extruded', 'getElevation'],
          update: this.calculateElevations,
          noAlloc: noAlloc
        },
        fillColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          accessor: 'getFillColor',
          update: this.calculateFillColors,
          noAlloc: noAlloc
        },
        lineColors: {
          alias: 'colors',
          size: 4,
          type: GL.UNSIGNED_BYTE,
          accessor: 'getLineColor',
          update: this.calculateLineColors,
          noAlloc: noAlloc
        },
        pickingColors: { size: 3, type: GL.UNSIGNED_BYTE, update: this.calculatePickingColors, noAlloc: noAlloc }
      });
      /* eslint-enable max-len */
    }
  }, {
    key: 'updateAttribute',
    value: function updateAttribute(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;

      if (props.fp64 !== oldProps.fp64) {
        var attributeManager = this.state.attributeManager;


        if (props.fp64 && props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          /* eslint-disable max-len */
          attributeManager.add({
            positions64xyLow: { size: 2, accessor: 'fp64', update: this.calculatePositionsLow },
            nextPositions64xyLow: { size: 2, accessor: 'fp64', update: this.calculateNextPositionsLow }
          });
          /* eslint-enable max-len */
        } else {
          attributeManager.remove(['positions64xyLow', 'nextPositions64xyLow']);
        }
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var _props = this.props,
          extruded = _props.extruded,
          lightSettings = _props.lightSettings,
          elevationScale = _props.elevationScale;


      var renderUniforms = Object.assign({}, uniforms, {
        extruded: extruded ? 1.0 : 0.0,
        elevationScale: elevationScale
      }, lightSettings);

      this.state.models.forEach(function (model) {
        model.render(renderUniforms);
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(updateParams) {
      _get(SolidPolygonLayer.prototype.__proto__ || Object.getPrototypeOf(SolidPolygonLayer.prototype), 'updateState', this).call(this, updateParams);

      this.updateGeometry(updateParams);
      this.updateAttribute(updateParams);

      var props = updateParams.props,
          oldProps = updateParams.oldProps;


      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded || props.wireframe !== oldProps.wireframe;

      if (regenerateModels) {
        this.setState(Object.assign({
          // Set a flag to set attributes to new models
          modelsChanged: true
        }, this._getModels(this.context.gl)));
      }

      if (props.extruded !== oldProps.extruded) {
        this.state.attributeManager.invalidate('extruded');
      }
      if (props.fp64 !== oldProps.fp64) {
        this.state.attributeManager.invalidate('fp64');
      }
    }
  }, {
    key: 'updateGeometry',
    value: function updateGeometry(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          changeFlags = _ref3.changeFlags;

      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);

      // When the geometry config  or the data is changed,
      // tessellator needs to be invoked
      if (geometryConfigChanged) {
        // TODO - avoid creating a temporary array here: let the tesselator iterate
        var polygons = props.data.map(props.getPolygon);

        this.setState({
          polygonTesselator: new PolygonTesselator({ polygons: polygons, IndexType: this.state.IndexType })
        });

        this.state.attributeManager.invalidateAll();
      }

      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {
        this.state.polygonTesselator.updatePositions({
          fp64: props.fp64,
          extruded: props.extruded
        });
      }
    }
  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          modelsChanged = _state.modelsChanged;

      // Figure out data length

      attributeManager.update({
        data: props.data,
        numInstances: 0,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (modelsChanged) {
        this._updateAttributes(attributeManager.attributes);
        // clear the flag
        this.setState({ modelsChanged: false });
      } else {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        this._updateAttributes(changedAttributes);
      }
    }
  }, {
    key: '_updateAttributes',
    value: function _updateAttributes(attributes) {
      var modelsByName = this.state.modelsByName;


      for (var modelName in modelsByName) {
        var model = modelsByName[modelName];

        if (modelName === 'TOP') {
          model.setVertexCount(this.state.numVertex);
        } else {
          model.setInstanceCount(this.state.numInstances);
        }

        var attributeMap = ATTRIBUTE_MAPS[modelName];
        var newAttributes = {};
        for (var attributeName in attributes) {
          var attribute = attributes[attributeName];
          var attributeOverride = attributeMap[attributeName];

          if (attributeOverride) {
            var newAttribute = Object.assign({}, attribute, attributeOverride);
            newAttributes[attributeOverride.name || attributeName] = newAttribute;
          }
        }
        model.setAttributes(newAttributes);
      }
    }
  }, {
    key: '_getModels',
    value: function _getModels(gl) {
      var _props2 = this.props,
          id = _props2.id,
          filled = _props2.filled,
          extruded = _props2.extruded,
          wireframe = _props2.wireframe;


      var models = {};

      if (filled) {
        models.TOP = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-top',
          geometry: new Geometry({
            drawMode: GL.TRIANGLES,
            attributes: {
              vertexPositions: { size: 2, isGeneric: true, value: new Float32Array([0, 1]) },
              nextPositions: { size: 3, isGeneric: true, value: new Float32Array(3) },
              nextPositions64xyLow: { size: 2, isGeneric: true, value: new Float32Array(2) }
            }
          }),
          uniforms: {
            isSideVertex: 0
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        }));
      }
      if (filled && extruded) {
        models.SIDE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-side',
          geometry: new Geometry({
            drawMode: GL.TRIANGLE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_FILL_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isinstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }
      if (extruded && wireframe) {
        models.WIRE = new Model(gl, Object.assign({}, this.getShaders(), {
          id: id + '-wire',
          geometry: new Geometry({
            drawMode: GL.LINE_STRIP,
            vertexCount: 4,
            attributes: {
              vertexPositions: { size: 2, value: SIDE_WIRE_POSITIONS }
            }
          }),
          uniforms: {
            isSideVertex: 1
          },
          isinstanced: 1,
          shaderCache: this.context.shaderCache
        }));
      }

      return {
        models: [models.WIRE, models.SIDE, models.TOP].filter(Boolean),
        modelsByName: models
      };
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      attribute.value = this.state.polygonTesselator.indices();
      attribute.target = GL.ELEMENT_ARRAY_BUFFER;
      var numVertex = attribute.value.length / attribute.size;
      this.setState({ numVertex: numVertex });
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      attribute.value = this.state.polygonTesselator.positions();
      var numInstances = attribute.value.length / attribute.size;
      this.setState({ numInstances: numInstances });
    }
  }, {
    key: 'calculatePositionsLow',
    value: function calculatePositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.positions64xyLow();
    }
  }, {
    key: 'calculateNextPositions',
    value: function calculateNextPositions(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions();
    }
  }, {
    key: 'calculateNextPositionsLow',
    value: function calculateNextPositionsLow(attribute) {
      attribute.value = this.state.polygonTesselator.nextPositions64xyLow();
    }
  }, {
    key: 'calculateElevations',
    value: function calculateElevations(attribute) {
      var _this2 = this;

      if (this.props.extruded) {
        attribute.isGeneric = false;
        attribute.value = this.state.polygonTesselator.elevations({
          getElevation: function getElevation(polygonIndex) {
            return _this2.props.getElevation(_this2.props.data[polygonIndex]);
          }
        });
      } else {
        attribute.isGeneric = true;
        attribute.value = new Float32Array(1);
      }
    }
  }, {
    key: 'calculateFillColors',
    value: function calculateFillColors(attribute) {
      var _this3 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'fillColors',
        getColor: function getColor(polygonIndex) {
          return _this3.props.getFillColor(_this3.props.data[polygonIndex]);
        }
      });
    }
  }, {
    key: 'calculateLineColors',
    value: function calculateLineColors(attribute) {
      var _this4 = this;

      attribute.value = this.state.polygonTesselator.colors({
        key: 'lineColors',
        getColor: function getColor(polygonIndex) {
          return _this4.props.getLineColor(_this4.props.data[polygonIndex]);
        }
      });
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      attribute.value = this.state.polygonTesselator.pickingColors();
    }
  }]);

  return SolidPolygonLayer;
}(Layer);

export default SolidPolygonLayer;


SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHBlcmltZW50YWwtbGF5ZXJzL3NyYy9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ09PUkRJTkFURV9TWVNURU0iLCJMYXllciIsImV4cGVyaW1lbnRhbCIsImVuYWJsZTY0Yml0U3VwcG9ydCIsImdldCIsIkdMIiwiTW9kZWwiLCJHZW9tZXRyeSIsIlBvbHlnb25UZXNzZWxhdG9yIiwidnMiLCJ2czY0IiwiZnMiLCJkZWZhdWx0TGluZUNvbG9yIiwiZGVmYXVsdEZpbGxDb2xvciIsImRlZmF1bHRQcm9wcyIsImZpbGxlZCIsImV4dHJ1ZGVkIiwid2lyZWZyYW1lIiwiZnA2NCIsImVsZXZhdGlvblNjYWxlIiwiZ2V0UG9seWdvbiIsImYiLCJnZXRFbGV2YXRpb24iLCJnZXRGaWxsQ29sb3IiLCJnZXRMaW5lQ29sb3IiLCJsaWdodFNldHRpbmdzIiwibGlnaHRzUG9zaXRpb24iLCJhbWJpZW50UmF0aW8iLCJkaWZmdXNlUmF0aW8iLCJzcGVjdWxhclJhdGlvIiwibGlnaHRzU3RyZW5ndGgiLCJudW1iZXJPZkxpZ2h0cyIsIlNJREVfRklMTF9QT1NJVElPTlMiLCJGbG9hdDMyQXJyYXkiLCJTSURFX1dJUkVfUE9TSVRJT05TIiwiQVRUUklCVVRFX01BUFMiLCJUT1AiLCJpbmRpY2VzIiwiaW5zdGFuY2VkIiwicG9zaXRpb25zIiwicG9zaXRpb25zNjR4eUxvdyIsImVsZXZhdGlvbnMiLCJmaWxsQ29sb3JzIiwibmFtZSIsInBpY2tpbmdDb2xvcnMiLCJTSURFIiwibmV4dFBvc2l0aW9ucyIsIm5leHRQb3NpdGlvbnM2NHh5TG93IiwiV0lSRSIsImxpbmVDb2xvcnMiLCJTb2xpZFBvbHlnb25MYXllciIsInByb3BzIiwibW9kdWxlcyIsImdsIiwiY29udGV4dCIsInNldFN0YXRlIiwibnVtSW5zdGFuY2VzIiwiSW5kZXhUeXBlIiwiZ2V0RXh0ZW5zaW9uIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsIm5vQWxsb2MiLCJhZGQiLCJzaXplIiwiaXNJbmRleGVkIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImFjY2Vzc29yIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiY2FsY3VsYXRlTmV4dFBvc2l0aW9ucyIsImNhbGN1bGF0ZUVsZXZhdGlvbnMiLCJhbGlhcyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlRmlsbENvbG9ycyIsImNhbGN1bGF0ZUxpbmVDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwib2xkUHJvcHMiLCJjb29yZGluYXRlU3lzdGVtIiwiTE5HTEFUIiwiY2FsY3VsYXRlUG9zaXRpb25zTG93IiwiY2FsY3VsYXRlTmV4dFBvc2l0aW9uc0xvdyIsInJlbW92ZSIsInVuaWZvcm1zIiwicmVuZGVyVW5pZm9ybXMiLCJPYmplY3QiLCJhc3NpZ24iLCJtb2RlbHMiLCJmb3JFYWNoIiwibW9kZWwiLCJyZW5kZXIiLCJ1cGRhdGVQYXJhbXMiLCJ1cGRhdGVHZW9tZXRyeSIsInVwZGF0ZUF0dHJpYnV0ZSIsInJlZ2VuZXJhdGVNb2RlbHMiLCJtb2RlbHNDaGFuZ2VkIiwiX2dldE1vZGVscyIsImludmFsaWRhdGUiLCJjaGFuZ2VGbGFncyIsImdlb21ldHJ5Q29uZmlnQ2hhbmdlZCIsImRhdGFDaGFuZ2VkIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiYWxsIiwicG9seWdvbnMiLCJkYXRhIiwibWFwIiwicG9seWdvblRlc3NlbGF0b3IiLCJpbnZhbGlkYXRlQWxsIiwidXBkYXRlUG9zaXRpb25zIiwiYnVmZmVycyIsImlnbm9yZVVua25vd25BdHRyaWJ1dGVzIiwiX3VwZGF0ZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJnZXRDaGFuZ2VkQXR0cmlidXRlcyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwibW9kZWxzQnlOYW1lIiwibW9kZWxOYW1lIiwic2V0VmVydGV4Q291bnQiLCJudW1WZXJ0ZXgiLCJzZXRJbnN0YW5jZUNvdW50IiwiYXR0cmlidXRlTWFwIiwibmV3QXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGUiLCJhdHRyaWJ1dGVPdmVycmlkZSIsIm5ld0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZXMiLCJpZCIsImdldFNoYWRlcnMiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiVFJJQU5HTEVTIiwidmVydGV4UG9zaXRpb25zIiwiaXNHZW5lcmljIiwidmFsdWUiLCJpc1NpZGVWZXJ0ZXgiLCJ2ZXJ0ZXhDb3VudCIsInNoYWRlckNhY2hlIiwiVFJJQU5HTEVfU1RSSVAiLCJpc2luc3RhbmNlZCIsIkxJTkVfU1RSSVAiLCJmaWx0ZXIiLCJCb29sZWFuIiwidGFyZ2V0IiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJsZW5ndGgiLCJwb2x5Z29uSW5kZXgiLCJjb2xvcnMiLCJrZXkiLCJnZXRDb2xvciIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLGlCQUFSLEVBQTJCQyxLQUEzQixFQUFrQ0MsWUFBbEMsUUFBcUQsU0FBckQ7SUFDT0Msa0IsR0FBMkJELFksQ0FBM0JDLGtCO0lBQW9CQyxHLEdBQU9GLFksQ0FBUEUsRzs7QUFDM0IsU0FBUUMsRUFBUixFQUFZQyxLQUFaLEVBQW1CQyxRQUFuQixRQUFrQyxTQUFsQzs7QUFFQTtBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLHNCQUFoQzs7QUFFQSxPQUFPQyxFQUFQLE1BQWUsbUNBQWY7QUFDQSxPQUFPQyxJQUFQLE1BQWlCLHNDQUFqQjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxxQ0FBZjs7QUFFQSxJQUFNQyxtQkFBbUIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFB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RixTLEVBQVc7QUFBQTs7QUFDN0JBLGdCQUFVVyxLQUFWLEdBQWtCLEtBQUszRSxLQUFMLENBQVc4QyxpQkFBWCxDQUE2QjBDLE1BQTdCLENBQW9DO0FBQ3BEQyxhQUFLLFlBRCtDO0FBRXBEQyxrQkFBVTtBQUFBLGlCQUFnQixPQUFLckcsS0FBTCxDQUFXNUIsWUFBWCxDQUF3QixPQUFLNEIsS0FBTCxDQUFXdUQsSUFBWCxDQUFnQjJDLFlBQWhCLENBQXhCLENBQWhCO0FBQUE7QUFGMEMsT0FBcEMsQ0FBbEI7QUFJRDs7O3dDQUNtQnZCLFMsRUFBVztBQUFBOztBQUM3QkEsZ0JBQVVXLEtBQVYsR0FBa0IsS0FBSzNFLEtBQUwsQ0FBVzhDLGlCQUFYLENBQTZCMEMsTUFBN0IsQ0FBb0M7QUFDcERDLGFBQUssWUFEK0M7QUFFcERDLGtCQUFVO0FBQUEsaUJBQWdCLE9BQUtyRyxLQUFMLENBQVczQixZQUFYLENBQXdCLE9BQUsyQixLQUFMLENBQVd1RCxJQUFYLENBQWdCMkMsWUFBaEIsQ0FBeEIsQ0FBaEI7QUFBQTtBQUYwQyxPQUFwQyxDQUFsQjtBQUlEOztBQUVEOzs7OzJDQUN1QnZCLFMsRUFBVztBQUNoQ0EsZ0JBQVVXLEtBQVYsR0FBa0IsS0FBSzNFLEtBQUwsQ0FBVzhDLGlCQUFYLENBQTZCaEUsYUFBN0IsRUFBbEI7QUFDRDs7OztFQTlVNEMzQyxLOztlQUExQmlELGlCOzs7QUFpVnJCQSxrQkFBa0J1RyxTQUFsQixHQUE4QixtQkFBOUI7QUFDQXZHLGtCQUFrQnBDLFlBQWxCLEdBQWlDQSxZQUFqQyIsImZpbGUiOiJzb2xpZC1wb2x5Z29uLWxheWVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Q09PUkRJTkFURV9TWVNURU0sIExheWVyLCBleHBlcmltZW50YWx9IGZyb20gJ2RlY2suZ2wnO1xuY29uc3Qge2VuYWJsZTY0Yml0U3VwcG9ydCwgZ2V0fSA9IGV4cGVyaW1lbnRhbDtcbmltcG9ydCB7R0wsIE1vZGVsLCBHZW9tZXRyeX0gZnJvbSAnbHVtYS5nbCc7XG5cbi8vIFBvbHlnb24gZ2VvbWV0cnkgZ2VuZXJhdGlvbiBpcyBtYW5hZ2VkIGJ5IHRoZSBwb2x5Z29uIHRlc3NlbGF0b3JcbmltcG9ydCB7UG9seWdvblRlc3NlbGF0b3J9IGZyb20gJy4vcG9seWdvbi10ZXNzZWxhdG9yJztcblxuaW1wb3J0IHZzIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXguZ2xzbCc7XG5pbXBvcnQgdnM2NCBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LTY0Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsJztcblxuY29uc3QgZGVmYXVsdExpbmVDb2xvciA9IFsweDAsIDB4MCwgMHgwLCAweGZmXTtcbmNvbnN0IGRlZmF1bHRGaWxsQ29sb3IgPSBbMHgwLCAweDAsIDB4MCwgMHhmZl07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgZmlsbGVkOiB0cnVlLFxuICAvLyBXaGV0aGVyIHRvIGV4dHJ1ZGVcbiAgZXh0cnVkZWQ6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIGRyYXcgYSBHTC5MSU5FUyB3aXJlZnJhbWUgb2YgdGhlIHBvbHlnb25cbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG5cbiAgLy8gZWxldmF0aW9uIG11bHRpcGxpZXJcbiAgZWxldmF0aW9uU2NhbGU6IDEsXG5cbiAgLy8gQWNjZXNzb3IgZm9yIHBvbHlnb24gZ2VvbWV0cnlcbiAgZ2V0UG9seWdvbjogZiA9PiBnZXQoZiwgJ3BvbHlnb24nKSB8fCBnZXQoZiwgJ2dlb21ldHJ5LmNvb3JkaW5hdGVzJyksXG4gIC8vIEFjY2Vzc29yIGZvciBleHRydXNpb24gaGVpZ2h0XG4gIGdldEVsZXZhdGlvbjogZiA9PiBnZXQoZiwgJ2VsZXZhdGlvbicpIHx8IGdldChmLCAncHJvcGVydGllcy5oZWlnaHQnKSB8fCAwLFxuICAvLyBBY2Nlc3NvciBmb3IgY29sb3JzXG4gIGdldEZpbGxDb2xvcjogZiA9PiBnZXQoZiwgJ2ZpbGxDb2xvcicpIHx8IGdldChmLCAncHJvcGVydGllcy5jb2xvcicpIHx8IGRlZmF1bHRGaWxsQ29sb3IsXG4gIGdldExpbmVDb2xvcjogZiA9PiBnZXQoZiwgJ2xpbmVDb2xvcicpIHx8IGdldChmLCAncHJvcGVydGllcy5jb2xvcicpIHx8IGRlZmF1bHRMaW5lQ29sb3IsXG5cbiAgLy8gT3B0aW9uYWwgc2V0dGluZ3MgZm9yICdsaWdodGluZycgc2hhZGVyIG1vZHVsZVxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFstMTIyLjQ1LCAzNy43NSwgODAwMCwgLTEyMi4wLCAzOC4wLCA1MDAwXSxcbiAgICBhbWJpZW50UmF0aW86IDAuMDUsXG4gICAgZGlmZnVzZVJhdGlvOiAwLjYsXG4gICAgc3BlY3VsYXJSYXRpbzogMC44LFxuICAgIGxpZ2h0c1N0cmVuZ3RoOiBbMi4wLCAwLjAsIDAuMCwgMC4wXSxcbiAgICBudW1iZXJPZkxpZ2h0czogMlxuICB9XG59O1xuXG4vLyBTaWRlIG1vZGVsIGF0dHJpYnV0ZXNcbmNvbnN0IFNJREVfRklMTF9QT1NJVElPTlMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgLy8gdG9wIGxlZnQgY29ybmVyXG4gIDAsXG4gIDEsXG4gIC8vIGJvdHRvbSBsZWZ0IGNvcm5lclxuICAwLFxuICAwLFxuICAvLyB0b3AgcmlnaHQgY29ybmVyXG4gIDEsXG4gIDEsXG4gIC8vIGJvdHRvbSByaWdodCBjb3JuZXJcbiAgMSxcbiAgMFxuXSk7XG5jb25zdCBTSURFX1dJUkVfUE9TSVRJT05TID0gbmV3IEZsb2F0MzJBcnJheShbXG4gIC8vIHRvcCByaWdodCBjb3JuZXJcbiAgMSxcbiAgMSxcbiAgLy8gdG9wIGxlZnQgY29ybmVyXG4gIDAsXG4gIDEsXG4gIC8vIGJvdHRvbSBsZWZ0IGNvcm5lclxuICAwLFxuICAwLFxuICAvLyBib3R0b20gcmlnaHQgY29ybmVyXG4gIDEsXG4gIDBcbl0pO1xuXG4vLyBNb2RlbCB0eXBlc1xuY29uc3QgQVRUUklCVVRFX01BUFMgPSB7XG4gIFRPUDoge1xuICAgIGluZGljZXM6IHtpbnN0YW5jZWQ6IDB9LFxuICAgIHBvc2l0aW9uczoge2luc3RhbmNlZDogMH0sXG4gICAgcG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogMH0sXG4gICAgZWxldmF0aW9uczoge2luc3RhbmNlZDogMH0sXG4gICAgZmlsbENvbG9yczoge25hbWU6ICdjb2xvcnMnLCBpbnN0YW5jZWQ6IDB9LFxuICAgIHBpY2tpbmdDb2xvcnM6IHtpbnN0YW5jZWQ6IDB9XG4gIH0sXG4gIFNJREU6IHtcbiAgICBwb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIHBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIG5leHRQb3NpdGlvbnM6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7aW5zdGFuY2VkOiAxfSxcbiAgICBlbGV2YXRpb25zOiB7aW5zdGFuY2VkOiAxfSxcbiAgICBmaWxsQ29sb3JzOiB7bmFtZTogJ2NvbG9ycycsIGluc3RhbmNlZDogMX0sXG4gICAgcGlja2luZ0NvbG9yczoge2luc3RhbmNlZDogMX1cbiAgfSxcbiAgV0lSRToge1xuICAgIHBvc2l0aW9uczoge2luc3RhbmNlZDogMX0sXG4gICAgcG9zaXRpb25zNjR4eUxvdzoge2luc3RhbmNlZDogMX0sXG4gICAgbmV4dFBvc2l0aW9uczoge2luc3RhbmNlZDogMX0sXG4gICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIGVsZXZhdGlvbnM6IHtpbnN0YW5jZWQ6IDF9LFxuICAgIGxpbmVDb2xvcnM6IHtuYW1lOiAnY29sb3JzJywgaW5zdGFuY2VkOiAxfSxcbiAgICBwaWNraW5nQ29sb3JzOiB7aW5zdGFuY2VkOiAxfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2xpZFBvbHlnb25MYXllciBleHRlbmRzIExheWVyIHtcbiAgZ2V0U2hhZGVycygpIHtcbiAgICByZXR1cm4gZW5hYmxlNjRiaXRTdXBwb3J0KHRoaXMucHJvcHMpXG4gICAgICA/IHt2czogdnM2NCwgZnMsIG1vZHVsZXM6IFsncHJvamVjdDY0JywgJ2xpZ2h0aW5nJywgJ3BpY2tpbmcnXX1cbiAgICAgIDoge3ZzLCBmcywgbW9kdWxlczogWydsaWdodGluZycsICdwaWNraW5nJ119OyAvLyAncHJvamVjdCcgbW9kdWxlIGFkZGVkIGJ5IGRlZmF1bHQuXG4gIH1cblxuICBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgY29uc3Qge2dsfSA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIEluZGV4VHlwZTogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5XG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5vQWxsb2MgPSB0cnVlO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICBpbmRpY2VzOiB7c2l6ZTogMSwgaXNJbmRleGVkOiB0cnVlLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcywgbm9BbGxvY30sXG4gICAgICBwb3NpdGlvbnM6IHtcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgYWNjZXNzb3I6IFsnZXh0cnVkZWQnLCAnZnA2NCddLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgbmV4dFBvc2l0aW9uczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICBhY2Nlc3NvcjogWydleHRydWRlZCcsICdmcDY0J10sXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVOZXh0UG9zaXRpb25zLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgZWxldmF0aW9uczoge1xuICAgICAgICBzaXplOiAxLFxuICAgICAgICBhY2Nlc3NvcjogWydleHRydWRlZCcsICdnZXRFbGV2YXRpb24nXSxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUVsZXZhdGlvbnMsXG4gICAgICAgIG5vQWxsb2NcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3JzOiB7XG4gICAgICAgIGFsaWFzOiAnY29sb3JzJyxcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRGaWxsQ29sb3InLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlRmlsbENvbG9ycyxcbiAgICAgICAgbm9BbGxvY1xuICAgICAgfSxcbiAgICAgIGxpbmVDb2xvcnM6IHtcbiAgICAgICAgYWxpYXM6ICdjb2xvcnMnLFxuICAgICAgICBzaXplOiA0LFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVDb2xvcicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVMaW5lQ29sb3JzLFxuICAgICAgICBub0FsbG9jXG4gICAgICB9LFxuICAgICAgcGlja2luZ0NvbG9yczoge3NpemU6IDMsIHR5cGU6IEdMLlVOU0lHTkVEX0JZVEUsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQaWNraW5nQ29sb3JzLCBub0FsbG9jfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlKHtwcm9wcywgb2xkUHJvcHN9KSB7XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICYmIHByb3BzLmNvb3JkaW5hdGVTeXN0ZW0gPT09IENPT1JESU5BVEVfU1lTVEVNLkxOR0xBVCkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgICAgICBwb3NpdGlvbnM2NHh5TG93OiB7c2l6ZTogMiwgYWNjZXNzb3I6ICdmcDY0JywgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc0xvd30sXG4gICAgICAgICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtzaXplOiAyLCBhY2Nlc3NvcjogJ2ZwNjQnLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlTmV4dFBvc2l0aW9uc0xvd31cbiAgICAgICAgfSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbnM2NHh5TG93JywgJ25leHRQb3NpdGlvbnM2NHh5TG93J10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtleHRydWRlZCwgbGlnaHRTZXR0aW5ncywgZWxldmF0aW9uU2NhbGV9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IHJlbmRlclVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgdW5pZm9ybXMsXG4gICAgICB7XG4gICAgICAgIGV4dHJ1ZGVkOiBleHRydWRlZCA/IDEuMCA6IDAuMCxcbiAgICAgICAgZWxldmF0aW9uU2NhbGVcbiAgICAgIH0sXG4gICAgICBsaWdodFNldHRpbmdzXG4gICAgKTtcblxuICAgIHRoaXMuc3RhdGUubW9kZWxzLmZvckVhY2gobW9kZWwgPT4ge1xuICAgICAgbW9kZWwucmVuZGVyKHJlbmRlclVuaWZvcm1zKTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgIHN1cGVyLnVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcyk7XG5cbiAgICB0aGlzLnVwZGF0ZUdlb21ldHJ5KHVwZGF0ZVBhcmFtcyk7XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGUodXBkYXRlUGFyYW1zKTtcblxuICAgIGNvbnN0IHtwcm9wcywgb2xkUHJvcHN9ID0gdXBkYXRlUGFyYW1zO1xuXG4gICAgY29uc3QgcmVnZW5lcmF0ZU1vZGVscyA9XG4gICAgICBwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0IHx8XG4gICAgICBwcm9wcy5maWxsZWQgIT09IG9sZFByb3BzLmZpbGxlZCB8fFxuICAgICAgcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8XG4gICAgICBwcm9wcy53aXJlZnJhbWUgIT09IG9sZFByb3BzLndpcmVmcmFtZTtcblxuICAgIGlmIChyZWdlbmVyYXRlTW9kZWxzKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNldCBhIGZsYWcgdG8gc2V0IGF0dHJpYnV0ZXMgdG8gbmV3IG1vZGVsc1xuICAgICAgICAgICAgbW9kZWxzQ2hhbmdlZDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhpcy5fZ2V0TW9kZWxzKHRoaXMuY29udGV4dC5nbClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkKSB7XG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgnZXh0cnVkZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKCdmcDY0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlR2VvbWV0cnkoe3Byb3BzLCBvbGRQcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnlDb25maWdDaGFuZ2VkID1cbiAgICAgIGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8XG4gICAgICAoY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmXG4gICAgICAgIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5nZXRQb2x5Z29uKSk7XG5cbiAgICAvLyBXaGVuIHRoZSBnZW9tZXRyeSBjb25maWcgIG9yIHRoZSBkYXRhIGlzIGNoYW5nZWQsXG4gICAgLy8gdGVzc2VsbGF0b3IgbmVlZHMgdG8gYmUgaW52b2tlZFxuICAgIGlmIChnZW9tZXRyeUNvbmZpZ0NoYW5nZWQpIHtcbiAgICAgIC8vIFRPRE8gLSBhdm9pZCBjcmVhdGluZyBhIHRlbXBvcmFyeSBhcnJheSBoZXJlOiBsZXQgdGhlIHRlc3NlbGF0b3IgaXRlcmF0ZVxuICAgICAgY29uc3QgcG9seWdvbnMgPSBwcm9wcy5kYXRhLm1hcChwcm9wcy5nZXRQb2x5Z29uKTtcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBvbHlnb25UZXNzZWxhdG9yOiBuZXcgUG9seWdvblRlc3NlbGF0b3Ioe3BvbHlnb25zLCBJbmRleFR5cGU6IHRoaXMuc3RhdGUuSW5kZXhUeXBlfSlcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCB8fFxuICAgICAgcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkIHx8XG4gICAgICBwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0XG4gICAgKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnVwZGF0ZVBvc2l0aW9ucyh7XG4gICAgICAgIGZwNjQ6IHByb3BzLmZwNjQsXG4gICAgICAgIGV4dHJ1ZGVkOiBwcm9wcy5leHRydWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXR0cmlidXRlcyhwcm9wcykge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbHNDaGFuZ2VkfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAvLyBGaWd1cmUgb3V0IGRhdGEgbGVuZ3RoXG4gICAgYXR0cmlidXRlTWFuYWdlci51cGRhdGUoe1xuICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgIHByb3BzLFxuICAgICAgYnVmZmVyczogcHJvcHMsXG4gICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgLy8gRG9uJ3Qgd29ycnkgYWJvdXQgbm9uLWF0dHJpYnV0ZSBwcm9wc1xuICAgICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChtb2RlbHNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl91cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZU1hbmFnZXIuYXR0cmlidXRlcyk7XG4gICAgICAvLyBjbGVhciB0aGUgZmxhZ1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7bW9kZWxzQ2hhbmdlZDogZmFsc2V9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVNYW5hZ2VyLmdldENoYW5nZWRBdHRyaWJ1dGVzKHtjbGVhckNoYW5nZWRGbGFnczogdHJ1ZX0pO1xuICAgICAgdGhpcy5fdXBkYXRlQXR0cmlidXRlcyhjaGFuZ2VkQXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHttb2RlbHNCeU5hbWV9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGZvciAoY29uc3QgbW9kZWxOYW1lIGluIG1vZGVsc0J5TmFtZSkge1xuICAgICAgY29uc3QgbW9kZWwgPSBtb2RlbHNCeU5hbWVbbW9kZWxOYW1lXTtcblxuICAgICAgaWYgKG1vZGVsTmFtZSA9PT0gJ1RPUCcpIHtcbiAgICAgICAgbW9kZWwuc2V0VmVydGV4Q291bnQodGhpcy5zdGF0ZS5udW1WZXJ0ZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuc2V0SW5zdGFuY2VDb3VudCh0aGlzLnN0YXRlLm51bUluc3RhbmNlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hcCA9IEFUVFJJQlVURV9NQVBTW21vZGVsTmFtZV07XG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVPdmVycmlkZSA9IGF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcblxuICAgICAgICBpZiAoYXR0cmlidXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGUgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZU92ZXJyaWRlKTtcbiAgICAgICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU92ZXJyaWRlLm5hbWUgfHwgYXR0cmlidXRlTmFtZV0gPSBuZXdBdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMobmV3QXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG5cbiAgX2dldE1vZGVscyhnbCkge1xuICAgIGNvbnN0IHtpZCwgZmlsbGVkLCBleHRydWRlZCwgd2lyZWZyYW1lfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBtb2RlbHMgPSB7fTtcblxuICAgIGlmIChmaWxsZWQpIHtcbiAgICAgIG1vZGVscy5UT1AgPSBuZXcgTW9kZWwoXG4gICAgICAgIGdsLFxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFNoYWRlcnMoKSwge1xuICAgICAgICAgIGlkOiBgJHtpZH0tdG9wYCxcbiAgICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRVMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uczoge3NpemU6IDIsIGlzR2VuZXJpYzogdHJ1ZSwgdmFsdWU6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDFdKX0sXG4gICAgICAgICAgICAgIG5leHRQb3NpdGlvbnM6IHtzaXplOiAzLCBpc0dlbmVyaWM6IHRydWUsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDMpfSxcbiAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uczY0eHlMb3c6IHtzaXplOiAyLCBpc0dlbmVyaWM6IHRydWUsIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KDIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBpc1NpZGVWZXJ0ZXg6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgIGlzSW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmlsbGVkICYmIGV4dHJ1ZGVkKSB7XG4gICAgICBtb2RlbHMuU0lERSA9IG5ldyBNb2RlbChcbiAgICAgICAgZ2wsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgICAgaWQ6IGAke2lkfS1zaWRlYCxcbiAgICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICAgIGRyYXdNb2RlOiBHTC5UUklBTkdMRV9TVFJJUCxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiA0LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtzaXplOiAyLCB2YWx1ZTogU0lERV9GSUxMX1BPU0lUSU9OU31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgICAgaXNTaWRlVmVydGV4OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc2luc3RhbmNlZDogMSxcbiAgICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZXh0cnVkZWQgJiYgd2lyZWZyYW1lKSB7XG4gICAgICBtb2RlbHMuV0lSRSA9IG5ldyBNb2RlbChcbiAgICAgICAgZ2wsXG4gICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgICAgaWQ6IGAke2lkfS13aXJlYCxcbiAgICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICAgIGRyYXdNb2RlOiBHTC5MSU5FX1NUUklQLFxuICAgICAgICAgICAgdmVydGV4Q291bnQ6IDQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uczoge3NpemU6IDIsIHZhbHVlOiBTSURFX1dJUkVfUE9TSVRJT05TfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICBpc1NpZGVWZXJ0ZXg6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzaW5zdGFuY2VkOiAxLFxuICAgICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGVsczogW21vZGVscy5XSVJFLCBtb2RlbHMuU0lERSwgbW9kZWxzLlRPUF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgbW9kZWxzQnlOYW1lOiBtb2RlbHNcbiAgICB9O1xuICB9XG5cbiAgY2FsY3VsYXRlSW5kaWNlcyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmluZGljZXMoKTtcbiAgICBhdHRyaWJ1dGUudGFyZ2V0ID0gR0wuRUxFTUVOVF9BUlJBWV9CVUZGRVI7XG4gICAgY29uc3QgbnVtVmVydGV4ID0gYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplO1xuICAgIHRoaXMuc2V0U3RhdGUoe251bVZlcnRleH0pO1xuICB9XG5cbiAgY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucG9zaXRpb25zKCk7XG4gICAgY29uc3QgbnVtSW5zdGFuY2VzID0gYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplO1xuICAgIHRoaXMuc2V0U3RhdGUoe251bUluc3RhbmNlc30pO1xuICB9XG4gIGNhbGN1bGF0ZVBvc2l0aW9uc0xvdyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLnBvc2l0aW9uczY0eHlMb3coKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZU5leHRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5uZXh0UG9zaXRpb25zKCk7XG4gIH1cbiAgY2FsY3VsYXRlTmV4dFBvc2l0aW9uc0xvdyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLm5leHRQb3NpdGlvbnM2NHh5TG93KCk7XG4gIH1cblxuICBjYWxjdWxhdGVFbGV2YXRpb25zKGF0dHJpYnV0ZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmV4dHJ1ZGVkKSB7XG4gICAgICBhdHRyaWJ1dGUuaXNHZW5lcmljID0gZmFsc2U7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmVsZXZhdGlvbnMoe1xuICAgICAgICBnZXRFbGV2YXRpb246IHBvbHlnb25JbmRleCA9PiB0aGlzLnByb3BzLmdldEVsZXZhdGlvbih0aGlzLnByb3BzLmRhdGFbcG9seWdvbkluZGV4XSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGUuaXNHZW5lcmljID0gdHJ1ZTtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgfVxuICB9XG5cbiAgY2FsY3VsYXRlRmlsbENvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmNvbG9ycyh7XG4gICAgICBrZXk6ICdmaWxsQ29sb3JzJyxcbiAgICAgIGdldENvbG9yOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRGaWxsQ29sb3IodGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlTGluZUNvbG9ycyhhdHRyaWJ1dGUpIHtcbiAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmNvbG9ycyh7XG4gICAgICBrZXk6ICdsaW5lQ29sb3JzJyxcbiAgICAgIGdldENvbG9yOiBwb2x5Z29uSW5kZXggPT4gdGhpcy5wcm9wcy5nZXRMaW5lQ29sb3IodGhpcy5wcm9wcy5kYXRhW3BvbHlnb25JbmRleF0pXG4gICAgfSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucG9seWdvblRlc3NlbGF0b3IucGlja2luZ0NvbG9ycygpO1xuICB9XG59XG5cblNvbGlkUG9seWdvbkxheWVyLmxheWVyTmFtZSA9ICdTb2xpZFBvbHlnb25MYXllcic7XG5Tb2xpZFBvbHlnb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=